<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Anatomy Stressors Q-Sort</title>

<style>
  :root { --gap: 10px; --card-pad: 10px; --col-w: 180px; }
  body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; }
  h1 { margin: 0 0 6px 0; font-size: 22px; }
  .sub { color:#555; margin: 0 0 14px 0; }

  /* side-by-side layout */
  .wrap { display:flex; flex-direction:row; align-items:flex-start; gap:20px; }
  .left { flex:0 0 45%; max-width:45%; max-height:75vh; overflow:auto; padding-right:8px; }
  .right { flex:1 1 55%; max-width:55%; display:flex; flex-direction:column; align-items:flex-start; }

  /* stack on narrow screens */
  @media (max-width: 900px) {
    .wrap { flex-direction:column; }
    .left, .right { max-width:100%; flex:0 0 auto; }
  }

  .pool, .grid { border:1px solid #ddd; border-radius:8px; padding:12px; background:#fafafa; }
  .pool { min-height:120px; }
  .cards { display:flex; flex-wrap:wrap; gap:var(--gap); }

  .card {
    background:#fff; border:1px solid #ddd; border-radius:8px; padding:var(--card-pad);
    width: calc(50% - var(--gap)/2); cursor:grab; user-select:none;
    box-shadow:0 1px 2px rgba(0,0,0,.05);
  }
  .card:active { cursor:grabbing; }

  /* GRID */
  .grid { overflow-x:hidden; overflow-y:auto; }
  .grid-sticky {
    position: sticky; top: 0;
    background: #f5faff;
    border: 1px solid #d6e6ff;
    padding: 8px 10px;
    border-radius: 6px;
    font-size: 13px;
    margin-bottom: 10px;
  }
  .grid-sticky b { font-weight: 700; }

  .rows { display:flex; flex-direction:column; gap:20px; }
  .row-label { font-weight:600; font-size:14px; color:#444; margin:6px 0; text-align:center; }

  .row-cols { display:flex; gap:var(--gap); justify-content:center; flex-wrap:wrap; }

  .col {
    width: var(--col-w);
    min-height: 240px;
    background:#fff; border:1px dashed #bbb; border-radius:8px; padding:8px;
    display:flex; flex-direction:column; gap:8px;
    max-height: 65vh;
    overflow-y: auto;
    scroll-behavior: smooth;
  }
  @media (max-width: 900px) { .col { max-height: 55vh; } }
  @media (max-width: 600px) { .col { width: 100%; min-height: 180px; max-height: 45vh; } }

  .col.dragover { background:#f0f7ff; border-color:#5a9bff; }
  .col-head { display:flex; justify-content:space-between; align-items:center; margin:0 0 6px 0; }
  .badge { font-size:12px; padding:2px 6px; border-radius:999px; background:#eef4ff; border:1px solid #cfe0ff; }
  .tiny { font-size:12px; color:#666; }
  .row { display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin:10px 0; }

  /* responsive: columns scale down nicely */
  @media (max-width: 1024px) { .col { width: 150px; } }
  @media (max-width: 600px) { .col { width: 100%; } }

  button {
    border:1px solid #1f7aed; background:#2a84ff; color:#fff; padding:10px 14px; border-radius:8px;
    font-weight:600; cursor:pointer;
  }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .note { background:#fff9e6; border:1px solid #ffe7a3; padding:10px; border-radius:8px; }

  /* Visual polish: Positive vs Negative rows, mobile height fix */
  .rows > .row-cols:first-of-type {
    background: #f4faff;       /* light blue tint for upper row (0 → +4) */
    border-radius: 8px;
    padding: 8px;
  }
  .rows > .row-cols:last-of-type {
    background: #fff7f7;       /* soft red tint for lower row (−1 → −4) */
    border-radius: 8px;
    padding: 8px;
  }

  @media (max-width: 600px) {
    .col { max-height: 45vh; overflow-y: auto; }
  }
</style>
</head>

<body>
  <h1>Anatomy Stressors Q-Sort</h1>
  <p class="sub">Sort the 43 statements from <b>−4 = least characteristic of my stress</b> to <b>+4 = most characteristic</b>. Each column shows its required count—fill exactly.</p>

  <div class="wrap">
    <!-- LEFT: Unsorted pool + actions -->
    <div class="left">
      <div class="pool">
        <div class="row">
          <strong>Unsorted Statements</strong>
          <span id="poolCount" class="badge">loading…</span>
        </div>
        <div id="pool" class="cards" aria-label="unsorted pool"></div>
        <p class="tiny">Drag a card into any column. You can drag between columns or back to the pool.</p>
      </div>

      <div style="height:12px"></div>
      <div class="note tiny">
        <b>Tip:</b> If a column is full, drop is blocked. Empty space means you still need to place cards there.
      </div>

      <div style="height:12px"></div>
      <div class="row">
        <button id="downloadBtn" disabled>Download CSV</button>
        <span class="tiny" id="status">Place all cards to enable download.</span>
      </div>

      <!-- Quick jump buttons -->
      <div class="row" style="margin-top:8px;">
        <button id="jumpPos">Go to 0 → +4</button>
        <button id="jumpNeg">Go to −1 → −4</button>
      </div>

      <div class="row" style="margin-top:8px;">
        <label for="pidInput"><b>Enter Participant ID:</b></label>
        <input id="pidInput" type="text" placeholder="e.g., P1234" style="padding:6px; margin:6px; border:1px solid #ccc; border-radius:4px;">
        <button id="submitQualtricsBtn" disabled>Submit to Qualtrics</button>
      </div>

      <p style="margin-top:10px; font-weight:bold; color:#d9534f;">
        ⚠️ After sorting all 43 statements, click <b>“Submit to Qualtrics”</b> to record your results in the survey.<br>
        Downloading the CSV is optional.
      </p>
      <p class="tiny">Submitting will send your Q-sort results directly back into the Qualtrics survey.</p>
    </div>

    <!-- RIGHT: Q-grid in two rows with sticky instructions -->
    <div class="right">
      <div class="grid">
        <div class="grid-sticky">
          <b>How to rank:</b> The <b>upper row</b> holds <b>0 to +4</b> (neutral to most characteristic).<br>
          The <b>lower row</b> holds <b>−1 to −4</b> (least characteristic).<br>
          <span class="tiny">Tip: Start with the <b>upper row (0 → +4)</b>, then complete the lower row.</span>
        </div>

        <div id="gridRows" class="rows">
          <!-- JS injects rows/columns -->
        </div>
      </div>
    </div>
  </div>

<script>
/* ----- Configuration ----- */
const scaleLabels = [-4,-3,-2,-1,0,1,2,3,4];          // indices 0..8
const distribution = [3,4,5,6,7, 6,5,4,3];            // -4..+4 must sum to 43
const csvPath = 'statements.csv';

/* ----- State ----- */
let statements = [];     // [{id,text}]
let placements = {};     // statementId -> columnIndex or 'pool'

/* ----- Helpers ----- */
function el(tag, attrs={}, ...children){
  const x = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v])=>{
    if(k==='class') x.className = v;
    else if(k==='html') x.innerHTML = v;
    else x.setAttribute(k,v);
  });
  children.forEach(c => x.append(c));
  return x;
}

async function loadCSV(path){
  const res = await fetch(path);
  if(!res.ok) throw new Error('Could not load statements.csv');
  const txt = await res.text();
  const rows = txt.trim().split(/\r?\n/);
  const out = [];
  for(let i=1;i<rows.length;i++){
    const line = rows[i];
    const idx = line.indexOf(',');
    const id = line.slice(0, idx).trim();
    const text = line.slice(idx+1).trim();
    if(id && text) out.push({ id, text });
  }
  return out;
}

function updatePoolCount(){
  const poolCount = Object.values(placements).filter(v => v==='pool').length;
  document.getElementById('poolCount').textContent = poolCount + ' remaining';
}

function canDrop(colIndex){
  const current = Object.values(placements).filter(v => v===colIndex).length;
  return current < distribution[colIndex];
}

function allPlaced(){
  return Object.values(placements).every(v => v!=='pool');
}

function refreshDownloadState(){
  const btn  = document.getElementById('downloadBtn');
  const qbtn = document.getElementById('submitQualtricsBtn');
  const st   = document.getElementById('status');
  const ready = allPlaced();
  btn.disabled = !ready;
  if (qbtn) qbtn.disabled = !ready;
  st.textContent = ready
    ? 'All set. You can download CSV or submit directly to Qualtrics.'
    : 'Place all cards to enable download/submit.';
}

function makeCard(s){
  const c = el('div', {class:'card', draggable:'true', 'data-id':s.id});
  c.textContent = s.text;
  c.addEventListener('dragstart', e=>{
    e.dataTransfer.setData('text/plain', s.id);
  });
  return c;
}

function attachDnDZones(){
  // Pool
  const pool = document.getElementById('pool');
  pool.addEventListener('dragover', e=>{ e.preventDefault(); pool.classList.add('dragover'); });
  pool.addEventListener('dragleave', ()=> pool.classList.remove('dragover'));
  pool.addEventListener('drop', e=>{
    e.preventDefault(); pool.classList.remove('dragover');
    const id = e.dataTransfer.getData('text/plain');
    const card = document.querySelector(`.card[data-id="${CSS.escape(id)}"]`);
    if(card){ pool.append(card); placements[id] = 'pool'; updatePoolCount(); refreshDownloadState(); updateColBadges(); }
  });

  // Columns
  document.querySelectorAll('.col').forEach((col, colIndex)=>{
    col.addEventListener('dragover', e=>{
      if(canDrop(colIndex)){ e.preventDefault(); col.classList.add('dragover'); }
    });
    col.addEventListener('dragleave', ()=> col.classList.remove('dragover'));
    col.addEventListener('drop', e=>{
      e.preventDefault(); col.classList.remove('dragover');
      const id = e.dataTransfer.getData('text/plain');
      if(!canDrop(colIndex)) return;
      const card = document.querySelector(`.card[data-id="${CSS.escape(id)}"]`);
      if(card){ col.append(card); placements[id] = colIndex; updatePoolCount(); refreshDownloadState(); updateColBadges(); }
    });
  });
}

function updateColBadges(){
  document.querySelectorAll('.col').forEach((col, idx)=>{
    const have = Array.from(col.querySelectorAll('.card')).length;
    const need = distribution[idx];
    const badge = col.querySelector('.badge');
    if (badge) badge.textContent = `${have}/${need}`;
  });
}

function downloadCSV(){
  const header = 'id,rank\n';
  const lines = statements.map(s=>{
    const p = placements[s.id];
    const rank = (typeof p === 'number') ? scaleLabels[p] : '';
    return `${s.id},${rank}`;
  }).join('\n');
  const blob = new Blob([header + lines], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = el('a', {href:url, download:'qsort_results.csv'});
  document.body.append(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

/* ----- Init ----- */
(async function(){
  try{
    statements = await loadCSV(csvPath);
  }catch(err){
    alert('Error loading statements.csv. Make sure it exists in the repo root.\n' + err.message);
    return;
  }

  // initial placements: all in pool
  statements.forEach(s => placements[s.id] = 'pool');

  const gridRows = document.getElementById('gridRows');

  /* Row 1 (TOP): 0 … +4  -> indices 4..8 */
  const rowTopLabel = el('div', {class:'row-label'}, 'Upper Row: Neutral to Positive (0 → +4)');
  const rowTopCols  = el('div', {class:'row-cols', id:'rowPos'});
  for (let i = 4; i <= 8; i++) {
    const label = scaleLabels[i];
    const head = el('div', {class:'col-head'},
      el('div', {}, el('strong', {html: (label>0?'+':'') + label})),
      el('span', {class:'badge'}, `0/${distribution[i]}`)
    );
    const col = el('div', {class:'col', 'data-col': i}, head);
    rowTopCols.append(col);
  }
  gridRows.append(rowTopLabel, rowTopCols);

  /* Row 2 (BOTTOM): −1 … −4  -> indices 0..3 */
  const rowBottomLabel = el('div', {class:'row-label'}, 'Lower Row: Least Characteristic (−1 → −4)');
  const rowBottomCols  = el('div', {class:'row-cols', id:'rowNeg'});
  for (let i = 0; i <= 3; i++) {
    const label = scaleLabels[i];
    const head = el('div', {class:'col-head'},
      el('div', {}, el('strong', {html: (label>0?'+':'') + label})),
      el('span', {class:'badge'}, `0/${distribution[i]}`)
    );
    const col = el('div', {class:'col', 'data-col': i}, head);
    rowBottomCols.append(col);
  }
  gridRows.append(rowBottomLabel, rowBottomCols);

  // fill pool with cards
  const pool = document.getElementById('pool');
  statements.forEach(s => pool.append( makeCard(s) ));
  updatePoolCount();

  attachDnDZones();
  updateColBadges();

  // Quick jump buttons
  document.getElementById('jumpPos')?.addEventListener('click', () => {
    document.getElementById('rowPos')?.scrollIntoView({ behavior:'smooth', block:'start' });
  });
  document.getElementById('jumpNeg')?.addEventListener('click', () => {
    document.getElementById('rowNeg')?.scrollIntoView({ behavior:'smooth', block:'start' });
  });

  // Autofill PID from URL (?pid=XXXX) when coming from Qualtrics
  const urlParams = new URLSearchParams(window.location.search);
  const pidFromUrl = urlParams.get('pid');
  if (pidFromUrl) {
    const pidInput = document.getElementById('pidInput');
    if (pidInput) pidInput.value = pidFromUrl;
  }

  document.getElementById('downloadBtn').addEventListener('click', downloadCSV);

  // === Qualtrics Redirect Settings (return to Qualtrics) ===
  const QUALTRICS_BASE = "https://shsu.co1.qualtrics.com/jfe/form/SV_9mLZQw7T45q9bcW?return=1";

  function submitToQualtrics(){
    if(!allPlaced()){
      alert("Please place all cards before submitting to Qualtrics.");
      return;
    }
    const pid = (document.getElementById('pidInput').value || '').trim();
    if(!pid){
      alert("Please enter a Participant ID before submitting.");
      return;
    }

    // Build URL safely (preserves ?return=1)
    const url = new URL(QUALTRICS_BASE);
    url.searchParams.set('pid', pid);
    for(let i=1; i<=43; i++){
      const place = placements[String(i)];
      const rank = (typeof place === 'number') ? scaleLabels[place] : '';
      url.searchParams.set('S'+i, rank);
    }
    window.location.href = url.toString();
  }

  document.getElementById('submitQualtricsBtn').addEventListener('click', submitToQualtrics);
})();
</script>
</body>
</html>
